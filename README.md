알고리즘 공부 노트
======================
- char c = sc.nextLine().charAt(0);	// 한 문자 입력.

- euc-kr : 2바이트
- utf-8  : 3바이트

- System.exit(0); // 종료.



1\. 개념정리
- 백트래킹 : 완전 탐색 방법 중 하나인 깊이 우선 탐색(DFS)을 진행하면서 조건을 확인, 해당 노드가 유망하지 않으면 더 이상 탐색하지 않는 것을 의마한다.
- 그리디(탐욕법) : 최적의 값을 구해야 하는 상황에서 사용되는 근시안적인 방법론으로 '각 단계에서 최적이라고 생각되는 것을 선택'해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 알고리즘이다.
    - 항상 최적의 값을 보장하는것이 아니라 최적의 값의 '근사한 값'을 목표로 한다.
    - 주로 문제를 분할 가능한 문제들로 분할한 뒤, 각 문제들에 대한 최적해를 구한 뒤 이를 결합하여 전체 문제의 최적해를 구하는 경우에 주로 사용된다.
    - 문제를 풀 때 두 가지 조건이 성립해야 그리디 알고리즘을 적용할 수 있습니다.
    - 탐욕 선택 속성 : 각 단계에서 '최선의 선택'을 했을 때 전체 문제에 대한 최적해를 구할 수 있는 경우를 말한다.   
      즉, 각 단계에서 가장 이상적인 선택을 하는 것이 전체적으로 최적의 결과를 가져온다는 것입니다.
    - 최적 부분 구조 : 전체 문제의 최적해가 '부분 문제의 최적해로 구성'될 수 있는 경우를 말합니다.          
      즉, 전체 문제를 작은 부분 문제로 나누어 각각의 부분 문제에서 최적의 해를 구한 후 이를 조합하여 전체 문제의 최적해를 구하는 것을 의미합니다.
    - 그리디 알고리즘의 단계
        1. 문제의 최적해 구조를 결정합니다.
        2. 문제의 구조에 맞게 선택 절차를 정의합니다. : 선택 절차(이 단계에서는 '현재 상태'에서 '최적인 선택'을 합니다. 이 선택은 이후에는 바뀌지 않습니다.)
        3. 선택 절차에 따라 선택을 수행합니다.
        4. 선택된 해가 문제의 조건을 만족하는지 검사합니다. : 적절성 검사(이 단계에서는 선택한 항목이 '문제의 조건'을 만족시키는지 확인합니다. 조건을 만족시키지 않으면 해당 항목은 제외됩니다.)
        5. 조건을 만족하지 않으면 해당 해를 제외합니다.
        6. 모든 선택이 완료되면 해답을 검사합니다. : 해답 검사(이 단계에서는 모든 선택이 완료되면, '최종 선택'이 '문제의 조건을 만족'시키는지 확인합니다. 조건을 만족시키면 해답으로 인정됩니다.)
        7. 조건을 만족하지 않으면 해답으로 인정되지 않습니다.
- 동적 계획법(DP) : 작은 문제의 해를 메모이제이션하여 중복 계산을 피하고, 이를 이용하여 큰 문제를 해결하는 방식
    1. 중복 부분 문제
    2. 최적 부분 구조
- 이진탐색 : 정렬된 일련의 값들이 주어졌을 때 그 값들 중 원하는 값을 찾는 알고리즘.
- 경곗값을 찾는 알고리즘
    - 이진 탐색을 기반으로 하기 때문에 데이터가 정렬되어 있어야 한다.
    - 시간 복잡도는 O(log n)
    - lower bound : 찾고자 하는 값 이상이 처음 나타나는 위치.
    - upper bound : 찾고자 하는 값보다 큰 값이 처음으로 나타나는 위치.
- 매개변수탐색 : 조건을 만족하는 최소값/최대값을 구하는 방법입니다.
    - 최적화 문제를 결정문제로 바꿔서 이분법을 이용해 해결하는 방법이다.
    - 주어진 범위 내에서 원하는 값 또는 조건에 일치하는 값을 찾아내는 알고리즘.
- 최적화문제(optimize) : 가능한 여러개의 답 중 가장 좋은 답을 찾는다.
    - 반환값은 대개 실수나 정수이므로 답의 경우의 수가 무한하다.
- 결정문제(decision) : 답은 이미 결정되어있다고 보고 문제를 푸는 것이다.
    - 예 혹은 아니오 형태의 답만이 나오는 문제들을 가리킨다.

분할정복(Divide & Conquore)
분할 : 문제를 더이상 분할할 수 없을 때까지 동일한 유형의 여러 하위 문제로 나눈다. 비교 연산과 이동 연산이 수행되지 않는다.
정복 : 가장 작은 단위의 하위 문제를 해결하여 정복한다.
조합 : 하위 문제에 대한 결과를 원래 문제에 대한 결과로 조합한다.
순환 호출의 깊이는 절반씩 줄어드므로 시간복잡도는 logN
합병 단계에는 최대 N번 비교함.

힙 :
- 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조이다.
- 최댓값, 최솟값을 쉽게 추출할 수 있는 자료구조이다.(최대힙, 최소힙)
- 최대힙 : 모든 부모 노드가 그 자식 노드보다 크거나 같은 값을 갖는 특성을 가집니다.
- 최소힙 : 모든 부모 노드가 그 자식 노드보다 작거나 같은 값을 갖는 특성을 가집니다.
- 힙을 저장하는 표준 자료구조는 배열이다.
- 구현을 쉽게 하기 위하여 배열의 첫 번째 인덱스인 0은 사용되지 않는다.
- 힙에서의 부모 노드와 자식 노드의 관계
- 왼쪽 자식의 인덱스 = (부모의 인덱스)*2
- 오른쪽 자식의 인덱스 = (부모의 인덱스)*2 +1
- 부모의 인덱스 = (자식의 인덱스)/2

최단거리 알고리즘 : 주어진 그래프에서 두 정점을 연결하는 가장 짧은 경로의 길이를 찾는, 경로에 포함되는 정점들을 찾는 문제.
가중치가 다르다? BFS말고 최단거리 알고리즘을 쓰자.
BFS는 가중치가 같은 그래프에서 최단거리 알고리즘으로 쓸 수 있다고 했는데 가중치가 다를 경우 최단거리 알고리즘을 써야 한다.
최단거리는 다익스트라, 벨만포드, 플로이드워셜 알고리즘이 있으며 이들 모두 일종의 DP입니다. 최적의 배열을 하나 만드는 것에 불과하기 때문이죠.
- 다익스트라 : 하나의 정점에서 출발했을 때 다른 모든 정점으로의 최단 경로를 구하는 알고리즘입니다.
  가장 적은 비용을 하나씩 선택한다.
- 벨만포드
- 플로이드 워셜 : 모든 쌍 최단거리 알고리즘입니다. u에서 v로 가는데 경유점을 거치는게 더 빠르다면 완화를 시켜 거리배열을 갱신시켜 나가는 것입니다.
  이 플로이드 워셜은 모든 쌍 최단거리경로를 구하기도 하고 i,j가 간접적, 직간접적으로 연결되어있는지도 확인할 수 있습니다.
  또한 그래프의 지름을 구할 수도 있습니다. 하지만 시간복잡도가 v^3이라 이 알고리즘은 문제에서 N의 크기가 어느정도 작을 때 쓸 수 있습니다.
  - 그래프의 지름은 해당 그래프내의 최단거리 중에서 최대거리를 뜻한다.
  - 모든 정점에서 모든 정점으로의 최단 경로를 구하고 싶을때 사용한다.
  - 거쳐가는 정점을 기준으로 알고리즘을 수행한다.

----------------------------------------------------------------------------------------------------
[알고리즘 관련 용어]
메모이제이션 : 컴퓨터 알고리즘 용어로, 동일한 계산을 반복해야 할 경우 한 번 계산한 결과를 메모리에 저장해 두었다가 꺼내 씀으로써 중복 계산을 방지할 수 있게 하는 기법이다.
동적계획법의 핵심이 되는 기술로써 결국 메모리라는 공간 비용을 투입해 계산에 소요되는 시간 비용을 줄이는 방식이다.
메모이제이션은 아무래도 학술적인 용어라 실제 현장에서는 캐싱(caching)이라는 단어를 더 많이 사용한다.
타뷸레이션 : 상향식 풀이.
선형 시간 알고리즘 : 코드의 수행시간이 입력의 크기에 정비례하는 코드로 대게 우리가 찾을 수 있는 알고리즘 중 가장 좋은 알고리즘인 경우가 많다.
점근적 표기법 : 상수 계수와 중요하지 않은 항목을 제거한 것.
제자리 정렬 : 입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리(공간)를 요구하지 않는 정렬 방법
LinkedList : 링크 인덱스만 변경하면 데이터의 이동은 무시할 수 있을 정도로 작아지기 때문에 제자리 정렬로 구현할 수 있다.(링크 인덱스만 변경하는 알고리즘에서 사용하면 됨.)
1초 연산 수 : 약 1억번
비교정렬 : 데이터를 비교하면서 찾는 정렬
불안정정렬 : 다른 부분리스트인데 떨어진 원소끼리 교환이 일어나는 정렬.
호어방식 : 피벗보다 작은 값은 왼쪽 부분에, 피벗보다 큰 값들은 오른쪽 부분에 치우치게 만드는 방식.
파티셔닝 : 피벗을 하나 설정하고 호어방식처럼 하는것.
선형적 : 직선
비선형적 : 직선이 아닌 모양
음수사이클 : 사이클의 모든 경로를 지나 원래 지점으로 돌아 왔을때, 최종적인 비용이 음수가 되는 경우.


재귀 -> 백트래킹
트리 -> 그리디
최적화문제 , 결정문제 -> 매개변수탐색

----------------------------------------------------------------------------------------------------
[주의사항]
1. [ 변수 실수형은 사용하지 말아야 한다 ]
   💡 부동소수점 오차
   변수에 실수형을 저장하면 오차가 발생하게 된다.
   실수형은 소수가 2진수로 저장되기 때문에 이를 나타낼 수 없을 경우 가장 근사한 값을 저장하기 때문이다.
   예를 들어 double 변수에 0.58을 저장하고 *100을 한다면 58이 나온다고 생각할 수 있지만 컴퓨터는 이를 저장하지 못하고 0.5799999로 저장하기 때문에 실제로는 57이 반환된다.
   따라서 실수를 계산할 때에는 최대한 정수범위 내에서 처리를 하거나 BigDecimal을 사용해야 한다.

2. [ BufferedReader ]
   Scanner : 띄어쓰기와 개행문자를 경계로 하여 입력 값을 인식한다. 그렇기 때문에 따로 가공할 필요가 없어 편리하다. 성능이 안좋음.
1) Scanner와 달리 BufferedReader는 개행문자만 경계로 인식하고 리턴타입이 String으로 고정되기 때문에 가공 필요한 경우가 있음.
2) read한 데이터는 Line단위로 나눠지기에 공백단위로 데이터를 가공하려면 따로 작업을 해주어야 하는데,
   그럴땐 StringTokenizer의 st.nextToken() 이나 array[] = s.split(" ") 를 사용하는게 대표적이다.

3. [ JAVA String ]
   3-1. concat() : 기존 스트링을 유지시키지 않고, 새로운 스트링을 리턴하므로, 새로운값에 대입해줘야 한다.
   3-2. charAt연산을 사용하면 char형으로 반환하는데, 아래와 같은 식으로 하면 해당 위치의 int값을 반환시킴.
   ex) s.charAt(i) - '0'

4.  [ char의 연산은 int형이 됨 ] int d2 = ch+ch2;
    [ char와 연산하면 int형이 됨 ] ex) '3' + 2
    ex) 2 + '3'
    [ String과 연산하면 String형이 됨 ] ex) 3 + "33"
    ex) "33" + 2

5. [ 종료시키는 법 ] System.exit(0);
6. [컬렉션 이슈]
   10만이상은 컬렉션에 담다가 메모리초과 오류 발생함. 힙공간의 총 용량보다 넘침.

   ArrayList , ArrayDeque , LinkedList : which one is best?
    - 인덱스로 데이터에 접근하고 끝에 삽입, 삭제만 할 경우에는 ArrayList를 사용하라
    - stack, queue, 혹은 deque로 ArrayDeque를 사용하라
    - 리스트를 순회할때 삽입, 삭제하거나 O(1)인 최악의 경우에 마지막에 삽입시 LinkedList를 사용하라
7. [소수]
   소수를 찾을때는 해당값의 루트까지만 확인한다.
   소수는 1과 자기자신만 약수로 가진다. 제일 작은 소수는 2이다.
8. [약수]
   어떤 수의 약수는 필히 2개의 쌍을 가지므로 짝수개의 약수를 가지지만, 제곱수는 홀수개의 약수를 가진다.
9. [for문]
    - for문을 그냥 쓰면 시간초과가 발생하는 문제도 있으므로, 경우의수를 줄일 수 있는 for-each문을 만들 방법도 생각해봐야 한다.
    - 다중for문을 탈출할때는 라벨을 사용하면 효율적이다.
10. [배열]
    - 2개이상의 배열을 써야할때는 Arrays.copyOf 같은 배열 카피도 고려해볼만하다.
    - 초기화할때 Arrays.fill 같은 메소드를 사용하면 코드량이 줄어든다.

13. [진법]
    - 진법의 변환은 복잡하므로 각 타입마다 메소드로 구현이 쉽게 가능하다.
    - radix(기수) : 숫자 표현(진법체계)에 기준이 되는 수
      ex) 2진수 => 10진수 , 10진수 => 8진수
----------------------------------------------------------------------------------------------------
순열 ( nPr ) : 순열이란 서로 다른 n개중에 r개를 선택하는 경우의 수를 의미합니다. (순서 상관 있음)
조합 ( nCr ) : 조합이란 서로 다른 n개중에 r개를 선택하는 경우의 수를 의미합니다. (순서 상관 없음)

----------------------------------------------------------------------------------------------------
시간초과 이슈
- LinkedList 말고 배열 쓰는게 훨씬 빠릅니다. LinkedList는 get/set 사용 시 O(N)이 걸립니다
- 연결리스트를 쓰게 된다면 탐색에 매번 O(k)의 시간복잡도가 드는 반면 배열은 O(1)의 시간복잡도가 걸리기 때문이다.
    - F:\eclipse-workspace\java\자료구조 시간복잡도.png

----------------------------------------------------------------------------------------------------
코딩테스트 준비[2024-02-15]

7. 누적합
- 누적합이란 요소들의 누적된 합의 의미로 어떠한 배열을 기반으로 앞에서 부터 요소들의 누적된 합을 저장해 새로이 배열을 만들어서
  이를 활용하는 것을 말합니다.
- 문제를 풀 때 "구간"에 대한 많은 "쿼리"가 나올 때 생각해야 될 것은 트리 또는 누적합입니다.
  여기서 트리는 세그먼트, 펜윅트리를 뜻합니다.  이 때 그 구간 안에 있는 요소들이 변하지 않는 정적 요소라면 누적합을 쓰면 됩니다.
8. 문제를 푸는 방법
    1) 최대, 최소 범위를 파악합니다.
    2) 단순 구현이라면 구현하자.
    3) 무식하게 풀 수 있다면 무식하게 풀자.
    4) 아니라면 다른 알고리즘을 생각하자.
    5) 제출하기전, 반례를 항상 생각하자.

9.
1) 인접행렬 ( 자바의 배열로 표현함 )
- 0과 1로 두 정점 사이의 경로를 표현함.
- 공간복잡도 : O(V^2)
- 시간복잡도(1개 간선 찾기) : O(1)
- 시간복잡도(모든 간선 찾기) : O(V^2)
2) 인접리스트 ( 자바의 LinkedList 로 표현함)
- 공간복잡도 : O(V + E)
- 시간복잡도(1개 간선 찾기) : O(V)
- 시간복잡도(모든 간선 찾기) : O(V + E)
- 차이 : 그래프가 희소할 때는 인접리스트, 조밀할때는 인접행렬이 좋다.
- 보통 인접리스트를 쓰면됨. 문제는 sparse한 그래프가 많이 나옴. (다만, 문제 또는 코딩인터뷰에서 인접행렬로 주어진다면 그대로 인접행렬로 푸는 것이 좋다.)
3) 맵과 방향벡터
- 방향은 -1,0 / 0,1 / 1,0 / 0,-1 을 더해가며 탐색해야한다.
10. 연결된 컴포넌트 (connected compont)
- 이러한 컴포넌트들을 번호를 붙여가며 색칠하는 알고리즘은 풀르드필(floodfill)이라고 합니다.
