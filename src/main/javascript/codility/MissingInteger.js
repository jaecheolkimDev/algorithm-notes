/**
    N 정수의 배열 A가 주어지면 A에서 발생하지 않는 가장 작은 양의 정수 (0보다 큰)를 반환합니다.

    예를 들어 A = [1, 3, 6, 4, 1, 2] 인 경우 함수는 5를 반환해야합니다.

    A = [1, 2, 3]이면 함수는 4를 반환해야합니다.

    A = [−1, −3]이면 함수는 1을 반환해야합니다.

    다음 가정을위한 효율적인 알고리즘을 작성하십시오 .

    N은 [ 1 .. 100,000 ] 범위의 정수 이며;
    배열 A의 각 요소는 [ -1,000,000 .. 1,000,000 ] 범위의 정수 입니다.
 */
// let A = [1,3,6,4,1,2];
// let A = [1,2,3];
// let A = [-1, -3];
let A = [-1, -3, 6, 1];

console.log('arr2 : ', A.sort((a, b) => ((a>b) - (a<b))));

let arr = A.sort((a, b) => ((a>b) - (a<b)));

/**
 * 케이스
 * 1. 양수일때
 * 2. 음수일때
 * 3. 섞여있을때
 */
let ans = 1;    // 1.양수 , 3.섞여있을때, 1이 나오면 값 증가 후 비교.
if(A[A.length - 1] <= 0){ // 2. 음수일때
    return 1;
}
for(let i=0; i < A.length; i++){
    if(A[i] > 0 && A[i] == ans){    // 핵심.
        ans++;
    }
}
console.log("ans : ", ans);